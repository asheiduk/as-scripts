#!/bin/bash

#
# git feature ...
#
# A redo of `git flow feature` adapted to my own style.
#
# Goals:
#
#	- Start a feature from develop OR some other branch OR commit-ish (i.e. last-success)
#		Also do not force develop == develop@{upstream}.
#
#	- Finish does not force feature == feature@{upstream} (may have been rebase right now)
#
#
# Other features:
#
#	- No configuration required! Defaults rulez!
#

#
# AH
#

#####################################################################
# git-sh-setup

dashless="$(basename -- "$0" | sed 's/-/ /')"
OPTIONS_SPEC="\
$dashless start <feature-name>
--
v,verbose!	show git commands
q,quiet!	suppress more output
"

SUBDIRECTORY_OK=true
. git-sh-setup

set_reflog_action "$dashless"

#?# require_work_tree_exists

#####################################################################
# support functions

#--------------------------------------------------------------------
# "git" with optional logging

git () {
	if [ -n "$OPT_VERBOSE" ]
	then
		(
			printf "%s git" "$PS4"
			command git rev-parse --sq-quote "$@"
		) 1>&2
	fi
	command git "$@"
}

#--------------------------------------------------------------------
# "summary actions"

declare -a SUMMARY_ACTIONS

# TODO: rename to "done/done-action/done-step/step-done/step-complete"?

summary-action () {
	if [ -n "$*" ]
	then
		SUMMARY_ACTIONS+=("$*")
	fi
}

show-summary () {
	if [ -z "$OPT_QUIET" ]
	then
		
		if (( ${#SUMMARY_ACTIONS[@]} > 0 ))
		then
			printf "\nSummary of actions:\n"
			printf " - %s\n" "${SUMMARY_ACTIONS[@]}"
		fi
	fi
}

#--------------------------------------------------------------------
# config & options

option () {
	local key="$1"

	# FIXME: implement
	true
}

gitflow-config-flag () {
	local key="$1"
	[ $(command git config --bool "gitflow.feature.finish.$key") = true ]
}

#--------------------------------------------------------------------
# git support

update-tracking-branch () {
	local branch="$1"

	eval $(git for-each-ref --shell --format "local origin=%(upstream:remotename) refspec=%(upstream:remoteref):%(upstream)" "refs/heads/$branch" )
	git fetch "$origin" "$refspec"
	summary-action "fetched '$branch' from '$origin'"
}

has-remote () {
	local branch="$1"
	git rev-parse --verify --quiet "$branch@{upstream}" >/dev/null 2>&1
}

upstream () {
	local branch="$1"
	git rev-parse --verify --quiet --abbrev-ref "$branch@{upstream}" 2>/dev/null
}

remote-name () {
	local branch="$1"
	# alternative: git config branch.$branch.remote
	git for-each-ref --format "%(upstream:remotename)" "refs/heads/$branch" 
}

tracking-status () {
	local branch="$1"
	
	# either: git for-each-ref --format="%(upstream:trackshort)" refs/heads/$branch
	#		gives "<", ">", "<>" or "="
	# or: git rev-list --count --left-right "$branch...$branch@{upstream}" | tr \\t ,

	local status
	status=$(git for-each-ref --format="%(upstream:trackshort)" "refs/heads/$branch") || return
	[ -n "$status" ] || return 1
	echo "$status"
}

#####################################################################

cmd_start () {
	local feature="$1"
	local base="develop"
	
	# 
	# TODO: checks:
	#	- $BASE exists
	#	- $feature_branch does NOt exist
	#	- $feature and $base are valid
	#	- if $base is a hash, translate it into an (existing) branch

	# TODO: (optional) fetch & update $BASE
	
	# create branch & checkout
	local feature_branch="feature/$feature"
	git checkout -b "$feature_branch" "$base"
	git config "gitflow.branch.$feature_branch.base" "$base"
	summary-action "created local branch '$feature_branch' from '$base'"
#	summary-action "You are now on branch '$feature_branch'"
	
	show-summary
}

cmd_finish () {

	local feature_branch="$(git symbolic-ref --short --quiet HEAD)"
	local base=develop

	trap "show-summary; exit" ERR
	

	# TODO: checks:
	#	current branch is a feature-branch
	# branch-exists "$base" || die
	# branch-exists "$feature_branch" || die


	#
	# prepare base branch
	#
	if has-remote "$base"
	then
		# fetch from upstream
		if option fetch || gitflow-config-flag fetch
		then
			update-tracking-branch "$base"
		fi

		# fast forward (if possible and necessary)
		case $(tracking-status "$base") in
			= | ">" )
				# local base is equal or ahead upstream - no action required
				;;
			"<")
				# local base is behind its upstream -- catch up!
				# TODO: guard with "option ff-base"?
				git fetch . "$(upstream "$base"):$base"
				summary-action "local base branch '$base' has been fast-forwarded to upstream"
				;;
			"<>")
				# base and upstream diverged -- abort!
				# TODO: try auto-rebase? would require checkout of base!
				trap ERR
				show-summary
				echo 1>&2
				echo 1>&2 "Local base branch '$base' has diverged from upstream."
				echo 1>&2 "Rebase '$base' onto '$base@{upstream}' or merge both branches and try again."
				exit 10
				;;
		esac
	fi

	#
	# prepare feature-branch
	#
	if has-remote "$feature_branch"
	then
		if option fetch || gitflow-config-flag fetch
		then
			update-tracking-branch "$feature_branch"
		fi
		# TODO: try FF local FB?
		# TODO: abort if remote FB changed?
	fi

	
	# rebase feature branch
	git rebase --rebase-merges "$base"
	summary-action "'$feature_branch' was rebased onto '$base'"

	# checkout base
	git checkout "$base"

	# merge feature branch
	case $(git rev-list --count "$base..$feature_branch") in
		0)
			summary-action "skipped merge - no new commits"
			;;
		1)
			git merge --no-edit --ff-only "$feature_branch"
			summary-action "'$feature_branch' was merged into '$base' using fast-forward"
			;;
		*)
			git merge --no-edit --no-ff "$feature_branch"
			summary-action "'$feature_branch' was merged into '$base'"
			;;
	esac
	
	# delete remote branch
	if has-remote "$feature_branch"
	then
		git push --delete "$(remote-name "$feature_branch")" "$feature_branch"
		summary-action "remote branch '$feature_branch' has been deleted"
	fi

	# delete local branch
	git branch -d "$feature_branch"
	summary-action "local branch '$feature_branch' has been deleted"
	
	# delete config
	git config --remove-section "gitflow.branch.$feature_branch"
	
	show-summary
}

#-------------

fetch_opts=
while [ $# != 0 ]
do
    case "$1" in
    -v|--verbose)
    	OPT_VERBOSE=true
    	;;
    -q|--quiet)
    	OPT_QUIET=true
    	;;
	--)
	    shift
	    break
	    ;;
    esac
    shift
done

case "$1" in
	start)
		shift
		cmd_start "$@"
		;;
	finish)
		shift
		cmd_finish "$@"
		;;
	*)
		usage
		;;
esac
